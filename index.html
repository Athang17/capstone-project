<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#4361ee">
    <title>Privacy-Preserving Code Assistant</title>
    <!-- Load Socket.IO first -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>

    <!-- Load TensorFlow.js with async to prevent blocking page load -->
    <script async src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>

    <!-- TensorFlow.js Hub removed due to ORB blocking issues -->

    <!-- Load local Flower library with async to prevent blocking page load -->
    <script async src="flower-client-browser.js"></script>

    <!-- Add Pico.css for better styling -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">

    <!-- Add loading indicator -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/spinkit@2.0.1/spinkit.min.css">

    <!-- Add Google Fonts -->
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap">

    <style>
        /* Simplified professional color scheme and variables */
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --accent-color: #0ea5e9;
            --background: #f5f5f7; /* Changed to a grey-toned off-white */
            --surface-primary: #f8f8fa;
            --surface-secondary: #f1f1f5;
            --surface-tertiary: #e2e2e8;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #cbd5e1;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;

            /* Reduced spacing and sizing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 0.75rem;
            --spacing-lg: 1rem;
            --spacing-xl: 1.5rem;
            --spacing-2xl: 2rem;

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;

            /* Simplified shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);

            --transition-fast: all 0.15s ease;
            --transition-normal: all 0.2s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Professional font stack and smaller base font size */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-primary);
            background: var(--background);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Simplified header with smaller fonts and better visibility */
        header {
            background: var(--surface-primary);
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-lg) var(--spacing-xl);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-sm);
        }

        header p {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Simplified typography with smaller sizes */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-md);
            line-height: 1.3;
        }

        h1 {
            font-size: 24px;
        }

        h2 {
            font-size: 18px;
        }

        h3 {
            font-size: 16px;
        }

        p {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-md);
        }

        /* Clean main layout */
        main {
            flex: 1;
            padding: var(--spacing-xl);
            display: grid;
            grid-template-columns: 3fr 1fr; /* Adjusted ratio to give more space to left column */
            gap: var(--spacing-xl);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            min-height: 0; /* Needed for proper scrolling */
        }

        /* Added left column for main content */
        .left-column {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xl);
            min-height: 0; /* Needed for proper scrolling */
            overflow: hidden; /* Prevent overflow */
        }

        /* Added right column for logs */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            min-height: 0; /* Needed for proper scrolling */
            overflow: hidden; /* Prevent overflow */
        }

        /* Simplified article styling */
        article {
            background: var(--surface-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            transition: var(--transition-normal);
        }

        article:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--primary-color);
        }

        /* Fixed width text areas with scrolling */
        textarea {
            width: 100%;
            max-width: 100%;
            min-height: 120px;
            max-height: 200px;
            padding: var(--spacing-md);
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            line-height: 1.4;
            resize: vertical;
            transition: var(--transition-normal);
            margin-bottom: var(--spacing-lg);
            overflow-y: auto;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent textarea from shrinking */
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Professional button styling */
        button {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            padding: var(--spacing-md) var(--spacing-lg);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-normal);
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        /* Secondary button variant */
        button.secondary {
            background: var(--surface-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        button.secondary:hover {
            background: var(--surface-tertiary);
            border-color: var(--primary-color);
        }

        /* Clean dashboard styling */
        #demo-dashboard {
            grid-column: 1 / -1;
            background: var(--surface-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            margin-top: var(--spacing-xl);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-lg);
        }

        .dashboard-card {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
        }

        .dashboard-card h3 {
            font-size: 15px;
            margin-bottom: var(--spacing-md);
        }

        /* Clean status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 13px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            background: var(--surface-secondary);
        }

        .indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--text-muted);
        }

        .indicator-dot.connected {
            background-color: var(--success-color);
        }

        .indicator-dot.updating {
            background-color: var(--warning-color);
        }

        /* Clean client badge */
        .client-badge {
            background: var(--surface-secondary);
            color: var(--text-secondary);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 500;
        }

        /* Simplified teacher container */
        .teacher-container {
            margin-top: var(--spacing-lg);
            padding: var(--spacing-lg);
            background: var(--surface-secondary);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--primary-color);
        }

        .teacher-container h3 {
            font-size: 14px;
            margin-bottom: var(--spacing-sm);
        }

        .teacher-container p {
            font-size: 13px;
            margin-bottom: var(--spacing-sm);
        }

        /* Clean footer */
        footer {
            background: var(--surface-primary);
            border-top: 1px solid var(--border-color);
            padding: var(--spacing-lg) var(--spacing-xl);
            text-align: center;
        }

        footer p {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            main {
                grid-template-columns: 1fr;
                padding: var(--spacing-lg);
            }

            header {
                padding: var(--spacing-md) var(--spacing-lg);
            }

            article {
                padding: var(--spacing-lg);
            }
        }

        /* Remove all flashy animations and effects */
        * {
            animation: none !important;
        }

        /* Added dashboard section styling with better spacing */
        .dashboard-section {
            background: var(--surface-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .dashboard-section h3 {
            margin: 0 0 var(--spacing-md) 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .dashboard-section h4 {
            margin: 0 0 var(--spacing-sm) 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* Update indicator box styling */
        .update-box {
            background: var(--surface-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-sm) 0;
        }

        /* Enhanced Expert Consultant Output styling */
        #teacher-advice-container {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin-top: var(--spacing-md);
            max-height: 400px;
            overflow-y: auto;
        }

        #teacher-advice {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        /* Style markdown-like content in expert output */
        #teacher-advice h1,
        #teacher-advice h2,
        #teacher-advice h3 {
            color: var(--primary-color);
            margin: var(--spacing-lg) 0 var(--spacing-md) 0;
            font-weight: 600;
        }

        #teacher-advice h1 {
            font-size: 18px;
        }

        #teacher-advice h2 {
            font-size: 16px;
        }

        #teacher-advice h3 {
            font-size: 14px;
        }

        #teacher-advice code {
            background: var(--surface-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        #teacher-advice pre {
            background: var(--surface-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        #teacher-advice ul,
        #teacher-advice ol {
            margin: var(--spacing-md) 0;
            padding-left: var(--spacing-lg);
        }

        #teacher-advice li {
            margin: var(--spacing-xs) 0;
        }

        #teacher-advice strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Log styling for right column */
        .log {
            background: var(--surface-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            height: 500px; /* Increased height */
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
            flex: 1; /* Allow log to take available space */
            min-height: 0; /* Needed for proper scrolling */
            word-break: break-word; /* Prevent horizontal overflow */
        }

        .log div {
            margin-bottom: var(--spacing-xs);
            padding: var(--spacing-xs);
            border-radius: var(--radius-xs);
        }

        .log .error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .log .success {
            background: rgba(34, 197, 94, 0.1);
            color: #22c55e;
        }

        .log .warning {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
        }
    </style>
</head>

<body>
    <header>
        <!-- Simplified header content -->
        <h2>Privacy-Preserving Code Assistant <span id="client-id" class="client-badge"></span></h2>
        <p>Status: <span id="status">Starting...</span></p>
    </header>

    <main>
        <div class="left-column">
            <article>
                <h2>Generate Python Code</h2>
                <textarea id="prompt-input" rows="4" placeholder="Enter your code request..."></textarea>
                <!-- Removed call icon from generate button -->
                <button id="generate-btn" class="primary">
                    <svg class="icon" viewBox="0 0 24 24" width="20" height="20">
                        <path d="M12 3L14.5 8.5L20 11L14.5 13.5L12 19L9.5 13.5L4 11L9.5 8.5L12 3Z" fill="currentColor">
                        </path>
                    </svg>
                    Generate Code
                </button>

                <!-- Loading indicator -->
                <div class="loading-container" id="loading">
                    <div class="spinner sk-chase">
                        <div class="sk-chase-dot"></div>
                        <div class="sk-chase-dot"></div>
                        <div class="sk-chase-dot"></div>
                        <div class="sk-chase-dot"></div>
                        <div class="sk-chase-dot"></div>
                        <div class="sk-chase-dot"></div>
                    </div>
                    <p>Processing your request...</p>
                </div>

                <div id="output-container" class="hidden">
                    <h3>Generated Code</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: var(--radius-md);">
                        <pre style="margin: 0; overflow-x: auto;"><code id="output-code" class="language-python" contenteditable="false"></code></pre>
                    </div>
                    <div id="feedback-controls" style="margin-top: var(--spacing-md);">
                        <button id="edit-btn" class="secondary">
                            <svg class="icon" viewBox="0 0 24 24" width="20" height="20">
                                <path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round"
                                    d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z">
                                </path>
                            </svg>
                            Edit Code
                        </button>
                        <button id="improve-btn" class="primary hidden">
                            <svg class="icon" viewBox="0 0 24 24" width="20" height="20">
                                <path d="M20 6L9 17L4 12" fill="none" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round"></path>
                            </svg>
                            Submit Improvement
                        </button>
                    </div>
                </div>
            </article>

            <article>
                <h2>Demonstration Dashboard</h2>

                <!-- Added spacing and boxes for dashboard sections -->
                <div class="dashboard-section">
                    <h3>Team Preference</h3>
                    <div class="update-box">
                        <p>Current Preference: <span id="preference-display">Neutral</span></p>
                    </div>
                </div>

                <div class="dashboard-section">
                    <h3>Privacy Controls</h3>
                    <label for="privacy-slider">Privacy Level (Epsilon): <span id="epsilon-value">1.0</span></label>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <input type="range" id="privacy-slider" min="0.1" max="5.0" value="1.0" step="0.1" style="flex:1;">
                        <button id="update-privacy-btn" class="secondary">Update</button>
                    </div>
                    <small>Lower epsilon means more noise and stronger privacy.</small>
                </div>

                <div class="dashboard-section">
                    <h3>Expert Consultant</h3>
                    <div class="expert-controls">
                        <!-- Removed lightning icon from global update button -->
                        <button id="call-teacher-btn">Global Update</button>
                        <div class="update-box">
                            <div id="model-update-indicator" class="update-indicator">
                                <span class="indicator-dot"></span>
                                <span class="indicator-text">Model Status: Ready</span>
                            </div>
                        </div>
                    </div>
                    <div class="teacher-container">
                        <h4>Expert Consultant Output</h4>
                        <div id="teacher-advice-container">
                            <div id="teacher-advice">No expert advice available yet. Click "Global Update" to request
                                expert input.</div>
                            <div id="teacher-timestamp" class="timestamp"></div>
                        </div>
                    </div>
                </div>
            </article>
        </div>

        <!-- Moved logs to right column -->
        <div class="right-column">
            <article>
                <h2>Connection Log</h2>
                <div class="log" id="log"></div>
            </article>
        </div>
    </main>

    <!-- Footer removed to avoid duplicate connection log -->

    <!-- Use type="module" to ensure this runs after page load and libraries are available -->
    <script type="module">
        // Function to check if fl object is available
        function checkFlowerLoaded() {
            return new Promise((resolve, reject) => {
                // If fl is already available, resolve immediately
                if (window.fl) {
                    logMessage("Flower library already loaded", "info");
                    resolve();
                    return;
                }

                // Otherwise, set up a check that runs every 100ms
                logMessage("Waiting for Flower library to load...", "info");
                const checkInterval = setInterval(() => {
                    if (window.fl) {
                        logMessage("Flower library loaded successfully", "success");
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);

                // Set a timeout to reject if it takes too long
                setTimeout(() => {
                    clearInterval(checkInterval);
                    reject(new Error("Timeout waiting for Flower library to load"));
                }, 10000); // 10 second timeout
            });
        }

        // Function to show/hide loading indicator with performance optimization
        function showLoading(isLoading) {
            const loadingElement = document.getElementById('loading');
            // Use requestAnimationFrame for smoother UI updates
            requestAnimationFrame(() => {
                if (isLoading) {
                    loadingElement.classList.add('active');
                } else {
                    loadingElement.classList.remove('active');
                }
            });
        }

        // Helper function to log messages to console and UI
        function logMessage(message, type = "info") {
            const clientId = getClientId();
            const prefix = clientId ? `[Client ${clientId}] ` : "";
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `[${timestamp}] ${prefix}${message}`;

            // Log to console with enhanced styling based on message type
            if (type === "error") {
                console.error(fullMessage);
            } else if (type === "success") {
                console.log("%c" + fullMessage, "color: green; font-weight: bold");
            } else if (type === "preference") {
                console.log("%c" + fullMessage, "color: purple; font-weight: bold");
            } else if (type === "model") {
                console.log("%c" + fullMessage, "color: blue; font-weight: bold");
            } else if (type === "warning") {
                console.warn(fullMessage);
            } else {
                console.log(fullMessage);
            }

            // Log to UI with performance optimization
            requestAnimationFrame(() => {
                const logElement = document.getElementById('log');
                const entry = document.createElement('div');
                entry.classList.add(type);
                entry.textContent = fullMessage;
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
            });
        }

        // Get client ID from URL parameter
        function getClientId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('client');
        }

        // Load a pre-trained code generation model with optimized lazy loading approach
        let codeModel;
        let modelLoadPromise = null;
        let modelLoadStarted = false;

        // Start model loading immediately in the background
        function startModelLoading() {
            if (modelLoadStarted) return;
            modelLoadStarted = true;

            // Use setTimeout to defer model loading until after page is interactive
            setTimeout(() => {
                loadCodeModel().catch(err => {
                    console.warn("Background model loading failed, will retry when needed", err);
                    modelLoadPromise = null;
                });
            }, 100);
        }

        async function loadCodeModel() {
            // If model is already loaded, return it immediately
            if (codeModel) return codeModel;

            // If model is currently loading, return the existing promise
            if (modelLoadPromise) return modelLoadPromise;

            // Start loading the model
            modelLoadPromise = (async () => {
                logMessage("Loading code generation model...", "info");

                try {
                    // Check if TensorFlow.js is loaded
                    if (typeof tf === 'undefined') {
                        throw new Error("TensorFlow.js is not loaded yet. Please wait and try again.");
                    }

                    // For this demo, we'll use a simple linear model for multi-dimensional preferences
                    // Dimensions: [verbosity, documentation, type_hinting]
                    const model = tf.sequential();

                    // Input is a 3-d feature vector; output is a 3-d preference vector
                    model.add(tf.layers.dense({
                        units: 3,
                        inputShape: [3],
                        activation: 'linear',
                        useBias: true
                    }));

                    // Compile with simple settings for preference learning
                    model.compile({
                        optimizer: tf.train.adam(0.01),
                        loss: 'meanSquaredError'
                    });

                    // Initialize with neutral preference (zeros)
                    // Kernel shape [in=3, out=3], bias shape [3]
                    const initialKernel = tf.zeros([3, 3]);
                    const initialBias = tf.zeros([3]);
                    model.layers[0].setWeights([initialKernel, initialBias]);

                    logMessage("Code generation model created successfully", "success");
                    codeModel = model;
                    return model;
                } catch (error) {
                    logMessage(`Error loading model: ${error.message}`, "error");
                    modelLoadPromise = null; // Reset promise so we can try again
                    modelLoadStarted = false; // Allow retry
                    throw error;
                }
            })();

            return modelLoadPromise;
        }

        // Start model loading in background after page loads
        if (document.readyState === 'complete') {
            startModelLoading();
        } else {
            window.addEventListener('load', startModelLoading);
        }

        // Optimized tokenizer with memoization for better performance
        const tokenCache = new Map();

        function tokenizeText(text, maxLength = 50) {
            // Check cache first
            const cacheKey = text.trim().toLowerCase();
            if (tokenCache.has(cacheKey)) {
                return tokenCache.get(cacheKey);
            }

            // In a real application, you would use a proper tokenizer
            // This is a simplified version for demonstration
            const words = cacheKey.split(/\s+/).slice(0, maxLength);
            const tokens = new Array(words.length);

            // Process words in batches for better performance
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                // Simple hash function to convert words to token IDs
                let hash = 0;
                for (let j = 0; j < word.length; j++) {
                    hash = ((hash << 5) - hash) + word.charCodeAt(j);
                    hash |= 0; // Convert to 32bit integer
                }
                tokens[i] = Math.abs(hash) % 10000; // Map to vocabulary size
            }

            // Pad to maxLength
            const result = new Array(maxLength).fill(0);
            tokens.forEach((token, i) => {
                result[i] = token;
            });

            // Store in cache (limit cache size)
            tokenCache.set(cacheKey, result);
            if (tokenCache.size > 50) {
                const oldestKey = tokenCache.keys().next().value;
                tokenCache.delete(oldestKey);
            }

            return result;
        }

        // Cache for generated code to improve performance
        const codeCache = new Map();

        // Function to request code generation from the server
        async function requestCodeGeneration(prompt) {
            return new Promise((resolve, reject) => {
                try {
                    // Check if socket is available
                    if (!window.socket) {
                        // Create a socket connection if not already established
                        window.socket = io('http://localhost:8080');

                        // Set up event listeners for the socket
                        setupSocketListeners();
                    }

                    // Function to clean up event listeners and clear timeout
                    let timeoutId;
                    const cleanupListeners = () => {
                        if (timeoutId) clearTimeout(timeoutId); // Clear the timeout when listeners are cleaned up
                        window.socket.off('generation_progress');
                        window.socket.off('generation_error');
                    };

                    // Set a timeout in case the server doesn't respond
                    timeoutId = setTimeout(() => {
                        cleanupListeners(); // Clean up event listeners on timeout
                        reject(new Error("Server response timeout"));
                    }, 60000); // 60 second timeout (increased from 10 seconds)

                    // Set up a one-time listener for the generation response
                    window.socket.once('generation_response', (response) => {
                        cleanupListeners(); // Clean up other listeners
                        if (response && response.code) {
                            logMessage("Received code from server", "success");
                            resolve(response.code);
                        } else {
                            reject(new Error("Invalid response from server"));
                        }
                    });

                    // Set up listeners for progress updates
                    window.socket.on('generation_progress', (progress) => {
                        logMessage(`Generation progress: ${progress.message}`, "info");
                    });

                    // Set up error listener
                    window.socket.once('generation_error', (error) => {
                        cleanupListeners(); // Clean up other listeners
                        logMessage(`Server error: ${error.error}`, "error");
                        reject(new Error(error.error));
                    });

                    // Emit the request to the server
                    logMessage("Sending prompt to server for code generation", "info");
                    window.socket.emit('request_generation', { prompt: prompt });

                    // Set a timeout in case the server doesn't respond
                    setTimeout(() => {
                        reject(new Error("Server response timeout"));
                    }, 60000); // 60 second timeout (increased from 10 seconds)

                } catch (error) {
                    console.error("Error requesting code generation:", error);
                    reject(error);
                }
            });
        }

        // Set up Socket.IO event listeners
        function setupSocketListeners() {
            if (!window.socket) return;

            // Listen for connection events
            window.socket.on('connect', () => {
                logMessage("Socket.IO connection established", "success");
            });

            window.socket.on('disconnect', () => {
                logMessage("Socket.IO connection lost", "error");
            });

            window.socket.on('connect_error', (error) => {
                logMessage(`Socket.IO connection error: ${error.message}`, "error");
            });

            // Listen for teacher_response event
            window.socket.on('teacher_response', (data) => {
                logMessage("Received teacher response from server", "success");
                // Update the teacher advice display
                const teacherAdviceElement = document.getElementById('teacher-advice');
                if (teacherAdviceElement && data.synthetic_data) {
                    teacherAdviceElement.textContent = data.synthetic_data;
                }
            });

            // Listen for global_preference_update event
            window.socket.on('global_preference_update', (data) => {
                logMessage("Received global preference update from server", "success");
                // Update the team preference display
                const preferenceDisplay = document.getElementById('preference-display');
                if (preferenceDisplay && data.preference) {
                    preferenceDisplay.textContent = data.preference;
                }
            });

            // Listen for preference updates
            window.socket.on('preference_updated', (data) => {
                const preferenceValue = data.preference_value;
                logMessage(`Model preference updated: ${preferenceValue}`, "preference");

                // Update the preference display
                const preferenceDisplay = document.getElementById('preference-display');
                if (preferenceDisplay) {
                    let preferenceText = "Neutral";
                    if (preferenceValue > 0.5) {
                        preferenceText = "Verbose Code";
                    } else if (preferenceValue < -0.5) {
                        preferenceText = "Concise Code";
                    }
                    preferenceDisplay.textContent = preferenceText;
                }

                // Log detailed preference information
                console.group('Preference Update Details');
                console.log(`Preference Value: ${preferenceValue}`);
                console.log(`Message: ${data.message}`);
                console.log(`Client ID: ${data.client_id}`);
                console.groupEnd();
            });

            // Listen for model update notifications
            window.socket.on('model_updated', (data) => {
                logMessage("Model has been updated with your preferences!", "model");

                // Log detailed model update information
                console.group('Model Update Details');
                console.log(`Message: ${data.message}`);
                console.log(`Updated by: ${data.updated_by}`);
                console.log(`Timestamp: ${new Date().toISOString()}`);
                console.groupEnd();

                // If we have a current prompt, regenerate code with updated model
                if (currentPrompt && currentPrompt.trim() !== '') {
                    logMessage("Regenerating code with updated model...", "model");
                    // Wait a moment before regenerating
                    setTimeout(() => {
                        document.getElementById('generate-btn').click();
                    }, 1000);
                }
            });
        }

        // Convert TensorFlow.js model weights to Flower format
        function getModelWeights(model) {
            return model.weights.map(w => {
                // Get the values as a Float32Array
                const tensorValues = w.val.dataSync();
                // Convert to regular array for serialization
                return Array.from(tensorValues);
            });
        }

        // Set model weights from Flower format
        function setModelWeights(model, weights) {
            // Skip if weights array is empty (happens on first round)
            if (!weights || weights.length === 0) {
                logMessage("Received empty weights, skipping", "info");
                return;
            }

            try {
                // Check if TensorFlow.js is loaded
                if (typeof tf === 'undefined') {
                    throw new Error("TensorFlow.js is not loaded yet. Please wait and try again.");
                }

                // Zip weights with model weights for easier handling
                const weightPairs = model.weights.map((w, i) => {
                    return { weight: w, values: weights[i] };
                });

                // Set each weight tensor
                weightPairs.forEach(pair => {
                    const tensor = tf.tensor(pair.values, pair.weight.val.shape);
                    pair.weight.val.assign(tensor);
                });

                logMessage("Updated model with weights from server", "success");
            } catch (e) {
                logMessage(`Error setting weights: ${e.message}`, "error");
            }
        }

        // Global epsilon (updated explicitly via the Update button)
        window.currentEpsilon = '1.0';

        // Apply differential privacy by adding Gaussian noise to model weights
        function applyDifferentialPrivacy(model) {
            try {
                if (typeof tf === 'undefined') {
                    throw new Error("TensorFlow.js is not loaded yet. Please wait and try again.");
                }
                const eps = Math.max(parseFloat(window.currentEpsilon) || 1.0, 0.0001);
                const stddev = 1.0 / eps;
                const noisyWeights = model.weights.map(w => {
                    const noise = tf.randomNormal(w.val.shape, 0, stddev, 'float32');
                    const noisyTensor = tf.add(w.val, noise);
                    const arr = Array.from(noisyTensor.dataSync());
                    noise.dispose();
                    noisyTensor.dispose();
                    return arr;
                });
                return noisyWeights;
            } catch (e) {
                logMessage(`Error applying differential privacy: ${e.message}`, "error");
                // Fallback to returning current (non-noised) weights if something goes wrong
                return getModelWeights(model);
            }
        }

        // Main function to initialize the client with optimized loading time and error handling
        async function initFlowerClient() {
            // Cache DOM elements for better performance
            const elements = {
                status: document.getElementById('status'),
                clientId: document.getElementById('client-id'),
                generateBtn: document.getElementById('generate-btn'),
                editBtn: document.getElementById('edit-btn'),
                improveBtn: document.getElementById('improve-btn'),
                promptInput: document.getElementById('prompt-input'),
                outputCode: document.getElementById('output-code'),
                outputContainer: document.getElementById('output-container'),
                loading: document.getElementById('loading'),
                privacySlider: document.getElementById('privacy-slider'),
                epsilonValue: document.getElementById('epsilon-value')
            };

            const clientId = getClientId() || "Unknown";

            // Display client ID
            elements.clientId.textContent = `#${clientId}`;
            elements.status.textContent = "Initializing...";

            try {
                // Start model loading in background immediately
                startModelLoading();

                // Start loading libraries in parallel with shorter timeout
                const flowerPromise = checkFlowerLoaded();

                // Check if TensorFlow.js is loaded
                const tfPromise = new Promise((resolve, reject) => {
                    if (typeof tf !== 'undefined') {
                        // TensorFlow is already available
                        logMessage("TensorFlow.js already loaded", "info");
                        tf.ready().then(resolve);
                    } else {
                        // Wait for TensorFlow to load
                        logMessage("Waiting for TensorFlow.js to load...", "info");
                        const checkInterval = setInterval(() => {
                            if (typeof tf !== 'undefined') {
                                clearInterval(checkInterval);
                                clearTimeout(timeoutId);
                                logMessage("TensorFlow.js loaded successfully", "success");
                                tf.ready().then(resolve);
                            }
                        }, 100);

                        // Set a timeout to reject if it takes too long
                        const timeoutId = setTimeout(() => {
                            clearInterval(checkInterval);
                            reject(new Error("Timeout waiting for TensorFlow.js to load"));
                        }, 10000); // 10 second timeout
                    }
                });

                // Wait for both libraries to load with timeout
                const librariesPromise = Promise.all([flowerPromise, tfPromise]);
                await Promise.race([
                    librariesPromise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error("Libraries loading timeout")), 8000))
                ]);

                logMessage("Libraries loaded successfully", "success");
                elements.status.textContent = "Libraries loaded. Loading model...";

                // Continue with model loading that was started in background
                const modelPromise = loadCodeModel();

                // Store training data
                window.currentPrompt = "";
                window.currentGeneratedCode = "";
                window.currentEditedCode = "";
                window.originalGeneratedCode = ""; // Add missing variable declaration

                // Implement a full Flower client with TensorFlow.js integration
                class MyFlowerClient extends fl.client.Client {
                    constructor(model) {
                        super();
                        this.model = model;
                    }

                    getWeights() {
                        logMessage("Getting model weights", "info");
                        return getModelWeights(this.model);
                    }

                    setWeights(weights) {
                        logMessage("Setting model weights from server", "info");
                        setModelWeights(this.model, weights);
                    }

                    async fit(parameters, config) {
                        logMessage("Fit called by server", "info");

                        // Check for synthetic data in config
                        if (config && config.synthetic_data) {
                            logMessage(`Received synthetic data: ${config.synthetic_data}`, "success");
                            // Display the teacher advice in the dashboard
                            const teacherAdviceElement = document.getElementById('teacher-advice');
                            if (teacherAdviceElement) {
                                teacherAdviceElement.textContent = config.synthetic_data;
                            }
                        }

                        // Set weights received from the server
                        this.setWeights(parameters);

                        // Skip training if we don't have user feedback data
                        if (!currentPrompt || !currentEditedCode) {
                            logMessage("No training data available, skipping training", "info");

                            // Request the latest global preference even if we skip training
                            if (window.socket && window.socket.connected) {
                                window.socket.emit('get_global_preference', { client_id: getClientId() });
                                logMessage("Requested latest global preference", "info");
                            }

                            return {
                                parameters: this.getWeights(),
                                num_examples: 0,
                                status: { message: "OK" }
                            };
                        }

                        logMessage("Training on user feedback...", "info");

                        // Analyze edits for multi-dimensional preferences
                        const original = currentGeneratedCode || '';
                        const edited = currentEditedCode || '';

                        // 1) Verbosity (lines)
                        const originalLineCount = original.split('\n').length;
                        const editedLineCount = edited.split('\n').length;
                        let verbosity = 0.0;
                        if (editedLineCount > originalLineCount) {
                            verbosity = 1.0;
                            logMessage("User made code longer - verbosity preference up", "info");
                        } else if (editedLineCount < originalLineCount) {
                            verbosity = -1.0;
                            logMessage("User made code shorter - verbosity preference down", "info");
                        } else {
                            verbosity = 0.1;
                            logMessage("Code length unchanged - small verbosity update", "info");
                        }

                        // 2) Documentation (comment count '#')
                        const countHash = (s) => (s.match(/#/g) || []).length;
                        const originalComments = countHash(original);
                        const editedComments = countHash(edited);
                        let documentation = 0.0;
                        if (editedComments > originalComments) {
                            documentation = 1.0;
                            logMessage("User added comments - documentation preference up", "info");
                        } else if (editedComments < originalComments) {
                            documentation = -1.0;
                            logMessage("User removed comments - documentation preference down", "info");
                        } else {
                            documentation = 0.1;
                            logMessage("Comments unchanged - small documentation update", "info");
                        }

                        // 3) Type hinting (annotations in signatures and returns)
                        const typePattern = /:\s*[A-Za-z_][\w\[\],\s\.\|]*/g;
                        const returnPattern = /->\s*[A-Za-z_][\w\[\],\s\.\|]*/g;
                        const countTypes = (s) => ((s.match(typePattern) || []).length + (s.match(returnPattern) || []).length);
                        const originalTypes = countTypes(original);
                        const editedTypes = countTypes(edited);
                        let typeHinting = 0.0;
                        if (editedTypes > originalTypes) {
                            typeHinting = 1.0;
                            logMessage("User added type hints - type_hinting preference up", "info");
                        } else if (editedTypes < originalTypes) {
                            typeHinting = -1.0;
                            logMessage("User removed type hints - type_hinting preference down", "info");
                        } else {
                            typeHinting = 0.1;
                            logMessage("Type hints unchanged - small type_hinting update", "info");
                        }

                        // Create training tensors for the multi-dimensional preference model
                        const inputTensor = tf.tensor2d([[1, 1, 1]], [1, 3]);
                        const targetTensor = tf.tensor2d([[verbosity, documentation, typeHinting]], [1, 3]);

                        // Get training config
                        const epochs = config.epochs || 1;
                        const batchSize = config.batch_size || 1;

                        const vectorStr = `v=${verbosity.toFixed(2)}, d=${documentation.toFixed(2)}, t=${typeHinting.toFixed(2)}`;
                        logMessage(`Training for ${epochs} epochs with preference vector { ${vectorStr} }`, "info");

                        // Train the model
                        const result = await this.model.fit(inputTensor, targetTensor, {
                            epochs: epochs,
                            batchSize: batchSize,
                            callbacks: {
                                onEpochEnd: (epoch, logs) => {
                                    logMessage(`Epoch ${epoch + 1}: loss=${logs.loss.toFixed(4)}`, "info");
                                }
                            }
                        });

                        logMessage(`Training complete. Final loss: ${result.history.loss.slice(-1)[0].toFixed(4)}`, "success");

                        // Clean up tensors
                        inputTensor.dispose();
                        targetTensor.dispose();

                        // Reset training data
                        currentPrompt = "";
                        currentGeneratedCode = "";
                        currentEditedCode = "";

                        // Get updated weights to send back to server
                        const updatedWeights = this.getWeights();

                        // Transparency: log original clean preference vector from model bias
                        try {
                            const layerWeights = this.model.layers[0].getWeights();
                            if (layerWeights && layerWeights[1]) {
                                const origVec = Array.from(layerWeights[1].dataSync());
                                console.log("Original preference vector:", origVec);
                            }
                        } catch (_) {}

                        // Apply Differential Privacy to the weights before sending
                        logMessage(`Applying Differential Privacy with Epsilon=${window.currentEpsilon}`, 'info');
                        const noisyWeights = applyDifferentialPrivacy(this.model);
                        // Minimal DP verification logging (first few weights)
                        try {
                            const flat = noisyWeights.flat();
                            const sample = flat.slice(0, 6).map(x => Number(x).toFixed(4));
                            logMessage(`DP applied (epsilon=${window.currentEpsilon}). Sample weights: [${sample.join(', ')}]`, 'info');
                        } catch (_) {}

                        // Transparency: log noisy preference vector (bias) being sent
                        try {
                            if (noisyWeights && noisyWeights[1]) {
                                const noisyVec = noisyWeights[1].slice(0, 3);
                                console.log("Noisy preference vector being sent:", noisyVec);
                            }
                        } catch (_) {}

                        // Display the current multi-dimensional preference in the dashboard
                        const preferenceDisplay = document.getElementById('preference-display');
                        if (preferenceDisplay) {
                            const pred = this.model.predict(tf.tensor2d([[1, 1, 1]], [1, 3]));
                            const values = Array.from(pred.dataSync());
                            pred.dispose();
                            const [v, d, t] = values;
                            const vText = v > 0.5 ? 'Verbose' : (v < -0.5 ? 'Concise' : 'Neutral Verbosity');
                            const dText = d > 0.5 ? 'High Documentation' : (d < -0.5 ? 'Minimal Documentation' : 'Neutral Documentation');
                            const tText = t > 0.5 ? 'Type-Hinted' : (t < -0.5 ? 'No Type Hints' : 'Neutral Type Hints');
                            const preferenceText = `${vText} | ${dText} | ${tText}`;
                            preferenceDisplay.textContent = preferenceText;
                            logMessage(`Updated team preference display: ${preferenceText}`, "info");
                        }

                        // Request the latest global preference after completing a round
                        if (window.socket && window.socket.connected) {
                            window.socket.emit('get_global_preference', { client_id: getClientId() });
                            logMessage("Requested latest global preference", "info");
                        }

                        return {
                            parameters: noisyWeights,
                            num_examples: 1, // We trained on one example
                            status: { message: "OK" }
                        };
                    }

                    async evaluate(parameters, config) {
                        logMessage("Evaluate called by server", "info");

                        // Set weights received from the server
                        this.setWeights(parameters);

                        // In a real implementation, you would evaluate on a validation set
                        // For this demo, we'll return a fixed loss value

                        logMessage("Evaluation complete", "success");

                        return {
                            loss: 0.1,
                            num_examples: 1,
                            status: { message: "OK" }
                        };
                    }
                }

                // Wait for model to finish loading
                const model = await modelPromise;
                elements.status.textContent = "Model loaded. Attempting to connect...";

                // Create client instance with our model
                const client = new MyFlowerClient(model);

                // Set up UI event handlers with optimized performance
                elements.generateBtn.addEventListener('click', async () => {
                    const prompt = elements.promptInput.value.trim();
                    if (!prompt) {
                        logMessage("Please enter a code request", "error");
                        return;
                    }

                    logMessage(`Sending prompt to server: ${prompt}`, "info");
                    elements.generateBtn.disabled = true;
                    elements.generateBtn.textContent = "Generating...";

                    // Show loading indicator
                    showLoading(true);

                    try {
                        // Use setTimeout to allow UI to update before processing
                        await new Promise(resolve => setTimeout(resolve, 50));

                        // Request code generation from the server
                        const code = await requestCodeGeneration(prompt);

                        // Display the generated code
                        elements.outputCode.textContent = code;
                        elements.outputContainer.classList.remove('hidden');

                        // Store the current prompt and generated code
                        window.currentPrompt = prompt;
                        window.currentGeneratedCode = code;
                        window.originalGeneratedCode = code; // Store original code for comparison

                        logMessage("Code received and displayed successfully", "success");
                    } catch (error) {
                        console.error("Generation error:", error);
                        logMessage(`Error generating code: ${error.message}`, "error");
                        elements.outputCode.textContent = "# Error generating code\n# Please try again with a different prompt";
                        elements.outputContainer.classList.remove('hidden');
                    } finally {
                        elements.generateBtn.disabled = false;
                        elements.generateBtn.textContent = "Generate Code";
                        // Hide loading indicator
                        showLoading(false);
                    }
                });

                elements.editBtn.addEventListener('click', () => {
                    // Make the code editable
                    elements.outputCode.contentEditable = "true";
                    elements.outputCode.focus();

                    // Show the improve button
                    elements.improveBtn.classList.remove('hidden');
                    elements.editBtn.classList.add('hidden');

                    logMessage("You can now edit the code. Click 'Submit Improvement' when done.", "info");
                });

                // Analyze code changes to produce multi-dimensional style vector
                function analyzeCodeChanges(original, edited) {
                    const safeOrig = original || '';
                    const safeEdit = edited || '';

                    // documentation: based on count of '#'
                    const countHash = (s) => (s.match(/#/g) || []).length;
                    const docDelta = countHash(safeEdit) - countHash(safeOrig);
                    const documentation = docDelta > 0 ? 1 : (docDelta < 0 ? -1 : 0);

                    // typeHinting: occurrences of parameter/return annotations
                    const typePattern = /:\s*[A-Za-z_][\w\[\],\s\.\|]*/g;
                    const returnPattern = /->\s*[A-Za-z_][\w\[\],\s\.\|]*/g;
                    const countHints = (s) => ((s.match(typePattern) || []).length + (s.match(returnPattern) || []).length);
                    const hintDelta = countHints(safeEdit) - countHints(safeOrig);
                    const typeHinting = hintDelta > 0 ? 1 : (hintDelta < 0 ? -1 : 0);

                    // modernSyntax: prefer f-strings over str.format
                    const countFstrings = (s) => ((s.match(/f"[\s\S]*?"/g) || []).length + (s.match(/f\'[\s\S]*?\'/g) || []).length);
                    const countFormat = (s) => (s.match(/\.format\s*\(/g) || []).length;
                    const fDelta = countFstrings(safeEdit) - countFstrings(safeOrig);
                    const formatDelta = countFormat(safeEdit) - countFormat(safeOrig);
                    let modernSyntax = 0;
                    if (fDelta > 0 && formatDelta <= 0) modernSyntax = 1;
                    else if (fDelta < 0 && formatDelta > 0) modernSyntax = -1;
                    else modernSyntax = 0;

                    return { documentation, typeHinting, modernSyntax };
                }

                // Helper to format preference vector for display (new dimensions)
                function formatPreferenceVector(obj) {
                    if (!obj || typeof obj !== 'object') return JSON.stringify(obj);
                    const parts = [];
                    if (obj.documentation !== undefined) {
                        parts.push(obj.documentation > 0.5 ? 'More Comments' : (obj.documentation < -0.5 ? 'Fewer Comments' : 'Neutral Comments'));
                    }
                    if (obj.typeHinting !== undefined) {
                        parts.push(obj.typeHinting > 0.5 ? 'Strict Type Hints' : (obj.typeHinting < -0.5 ? 'No Type Hints' : 'Neutral Type Hints'));
                    }
                    if (obj.modernSyntax !== undefined) {
                        parts.push(obj.modernSyntax > 0.5 ? 'Modern Syntax' : (obj.modernSyntax < -0.5 ? 'Legacy Syntax' : 'Neutral Syntax'));
                    }
                    return `Prefers: ${parts.join(', ')}`;
                }

                elements.improveBtn.addEventListener('click', () => {
                    // Get the edited code
                    window.currentEditedCode = elements.outputCode.textContent;

                    // Make the code non-editable again
                    elements.outputCode.contentEditable = "false";

                    // Hide the improve button, show edit button
                    elements.improveBtn.classList.add('hidden');
                    elements.editBtn.classList.remove('hidden');

                    // Analyze edit to compute multi-dimensional preference vector (documentation, typeHinting, modernSyntax)
                    const original = window.currentGeneratedCode || '';
                    const edited = window.currentEditedCode || '';
                    const preferenceVector = analyzeCodeChanges(original, edited);

                    // Display locally and log
                    const pretty = formatPreferenceVector(preferenceVector);
                    const display = document.getElementById('preference-display');
                    if (display) display.textContent = pretty;
                    logMessage(`Preference detected and applied locally: ${pretty}`, 'preference');

                    // Emit to server for immediate global update
                    if (window.socket && window.socket.connected) {
                        window.socket.emit('submit_improvement_and_learn', {
                            client_id: getClientId(),
                            preference: preferenceVector
                        });
                        logMessage('Submitted improvement for immediate learning (no averaging).', 'success');
                    } else {
                        logMessage('Socket connection not available; will apply locally only.', 'warning');
                    }
                });

                // Start the connection with improved timeout handling
                logMessage("Connecting to Flower server...", "info");

                // Set up connection with retry logic
                const connectWithRetry = async (retries = 3, delay = 2000) => {
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            logMessage(`Connection attempt ${attempt}/${retries}`, "info");
                            return await fl.client.startClient("http://localhost:8080", client);
                        } catch (err) {
                            if (attempt === retries) throw err;
                            logMessage(`Connection failed, retrying in ${delay / 1000}s...`, "error");
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                };

                // Race the connection against timeout
                const connectionPromise = connectWithRetry();
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("Connection timeout after 15 seconds")), 15000);
                });

                await Promise.race([connectionPromise, timeoutPromise]);

                elements.status.textContent = "SUCCESS: Connected to server!";
                logMessage("Flower client connected successfully!", "success");

            } catch (e) {
                // Handle specific error types
                if (e.message.includes("timeout")) {
                    elements.status.textContent = "ERROR: Server connection timeout";
                    logMessage("Could not connect to server - please check if server is running", "error");
                } else if (e.name === "NetworkError" || e.message.includes("network")) {
                    elements.status.textContent = "ERROR: Network connection failed";
                    logMessage("Network error - please check your connection", "error");
                } else {
                    elements.status.textContent = `ERROR: ${e.message}`;
                    logMessage(`Error starting Flower client: ${e.message}`, "error");
                }
                console.error("Initialization error:", e);
            }
        }

        // Initialize Privacy slider display and listener
        (function initPrivacyControls() {
            const slider = document.getElementById('privacy-slider');
            const valueEl = document.getElementById('epsilon-value');
            const updateBtn = document.getElementById('update-privacy-btn');
            if (slider && valueEl) {
                valueEl.textContent = slider.value;
                // oninput only updates label
                slider.addEventListener('input', () => { valueEl.textContent = slider.value; });
            }
            if (updateBtn && slider) {
                updateBtn.addEventListener('click', () => {
                    window.currentEpsilon = slider.value;
                    logMessage(`Privacy level set to Epsilon = ${window.currentEpsilon}. Future learning will use this setting.`, 'info');
                });
            }
        })();

        // Set up Global Update button functionality
        document.getElementById('call-teacher-btn').addEventListener('click', function () {
            logMessage("Requesting global updates...", "info");
            if (window.socket) {
                // Get the current prompt
                const currentPrompt = document.getElementById('prompt-input').value;

                // Update UI to show processing state
                const indicatorDot = document.querySelector('.indicator-dot');
                const indicatorText = document.querySelector('.indicator-text');
                indicatorDot.classList.add('updating');
                indicatorText.textContent = 'Model Status: Updating...';

                // Request teacher advice with the current prompt
                window.socket.emit('call_teacher', {
                    client_id: getClientId(),
                    prompt: currentPrompt
                });

                // Also request the latest global preference
                window.socket.emit('get_global_preference', { client_id: getClientId() });

                logMessage("Global update requested - fetching expert advice and updating model", "success");
            } else {
                logMessage("Socket connection not available", "error");
            }
        });

        // Set up socket connection and event listeners
        // Connect to the Socket.IO server with explicit URL
        window.socket = io('http://localhost:8080');

        // Listen for connection events
        window.socket.on('connect', function () {
            logMessage("Socket.IO connection established", "success");

            // Listen for teacher progress updates
            window.socket.on('teacher_progress', function (data) {
                const modelName = data.model || 'Llama 3.1 (via Groq API)';
                logMessage(`Expert consultant (${modelName}): ${data.message}`, "info");
            });

            // Listen for teacher advice responses
            window.socket.on('teacher_response', function (data) {
                const teacherAdvice = data.synthetic_data;
                const timestamp = data.timestamp || new Date().toLocaleString();
                const modelUpdated = data.model_updated || false;
                const modelName = data.model_name || 'Llama 3.1 (via Groq API)';

                // Update the teacher advice display
                document.getElementById('teacher-advice').textContent = teacherAdvice;
                document.getElementById('teacher-timestamp').textContent = `Updated: ${timestamp} (via ${modelName})`;

                // Reset the model update indicator
                const indicatorDot = document.querySelector('.indicator-dot');
                const indicatorText = document.querySelector('.indicator-text');
                indicatorDot.classList.remove('updating');

                if (modelUpdated) {
                    // Show success state
                    indicatorText.textContent = `Model Status: Updated with ${modelName}`;
                    logMessage(`Model updated with expert knowledge from ${modelName}`, "model");

                    // Flash effect to indicate update
                    document.getElementById('teacher-advice-container').style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
                    setTimeout(() => {
                        document.getElementById('teacher-advice-container').style.backgroundColor = '';
                    }, 1000);
                } else {
                    indicatorText.textContent = 'Model Status: Ready';
                }

                logMessage("Received new expert advice", "success");
            });

            // Listen for teacher errors
            window.socket.on('teacher_error', function (data) {
                const modelName = data.model_name || 'Llama 3.1 (via Groq API)';
                document.getElementById('teacher-advice').textContent = `Error from ${modelName}: ${data.error}`;
                document.getElementById('teacher-timestamp').textContent = `Error occurred: ${new Date().toLocaleString()}`;

                // Reset the model update indicator to error state
                const indicatorDot = document.querySelector('.indicator-dot');
                const indicatorText = document.querySelector('.indicator-text');
                indicatorDot.classList.remove('updating');
                indicatorDot.style.backgroundColor = 'red';
                indicatorText.textContent = `Model Status: Error with ${modelName}`;

                logMessage(`Expert consultant error (${modelName}): ${data.error}`, "error");

                // Reset after a delay
                setTimeout(() => {
                    indicatorDot.style.backgroundColor = '';
                    indicatorText.textContent = 'Model Status: Ready';
                }, 5000);
            });

            // Listen for global preference updates (vector-friendly display)
            window.socket.on('global_preference_update', function (data) {
                const pref = data.preference;
                const display = document.getElementById('preference-display');
                if (display) {
                    if (typeof pref === 'object' && pref !== null && !Array.isArray(pref)) {
                        display.textContent = formatPreferenceVector(pref);
                    } else if (Array.isArray(pref) && pref.length >= 3) {
                        const obj = { verbosity: pref[0], comments: pref[1], type_hinting: pref[2] };
                        display.textContent = formatPreferenceVector(obj);
                    } else if (typeof pref === 'number') {
                        display.textContent = pref.toFixed(2);
                    } else {
                        display.textContent = JSON.stringify(pref);
                    }
                }

                logMessage("Received global preference update: " + JSON.stringify(pref), "preference");
            });

            // Listen for model update notifications
            window.socket.on('model_update', function (data) {
                logMessage(data.message, "model");
            });
        });

        window.socket.on('disconnect', function () {
            logMessage("Socket.IO connection lost", "error");
        });

        window.socket.on('connect_error', function (error) {
            logMessage("Socket.IO connection error: " + error, "error");
        });

        // Start the initialization process
        initFlowerClient();
    </script>
</body>

</html>